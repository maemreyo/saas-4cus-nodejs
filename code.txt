// src/modules/admin/admin.route.ts
import { FastifyInstance } from 'fastify';
import { Container } from 'typedi';
import { AdminController } from './admin.controller';

export default async function adminRoutes(fastify: FastifyInstance) {
  const adminController = Container.get(AdminController);

  // Add admin middleware to all routes
  fastify.addHook('onRequest', async (request, reply) => {
    await (fastify as any).verifyJWT(request, reply);
    await (fastify as any).verifyRole(['ADMIN', 'SUPER_ADMIN'])(request, reply);
  });

  // ==================== USER MANAGEMENT ====================
  fastify.get('/users', adminController.searchUsers.bind(adminController));
  fastify.get('/users/:userId', adminController.getUserDetails.bind(adminController));
  fastify.put('/users/:userId', adminController.updateUser.bind(adminController));
  fastify.post('/users/bulk-action', adminController.bulkUserAction.bind(adminController));
  fastify.get('/users/statistics', adminController.getUserStatistics.bind(adminController));
  fastify.get('/users/:userId/activity', adminController.getUserActivity.bind(adminController));
  fastify.post('/users/:userId/impersonate', adminController.impersonateUser.bind(adminController));

  // ==================== SYSTEM METRICS ====================
  fastify.get('/metrics', adminController.getSystemMetrics.bind(adminController));
  fastify.get('/metrics/revenue', adminController.getRevenueMetrics.bind(adminController));
  fastify.get('/metrics/usage', adminController.getUsageMetrics.bind(adminController));
  fastify.get('/metrics/health', adminController.getSystemHealth.bind(adminController));
  fastify.get('/metrics/realtime', adminController.getRealTimeMetrics.bind(adminController));

  // ==================== CONTENT MODERATION ====================
  fastify.post('/moderation/review', adminController.reviewContent.bind(adminController));
  fastify.post('/moderation/bulk', adminController.bulkModerateContent.bind(adminController));
  fastify.get('/moderation/reports', adminController.getContentReports.bind(adminController));
  fastify.get('/moderation/statistics', adminController.getModerationStats.bind(adminController));
  fastify.get('/moderation/rules', adminController.getModerationRules.bind(adminController));
  fastify.put('/moderation/rules/:ruleId', adminController.updateModerationRule.bind(adminController));

  // ==================== SYSTEM CONFIGURATION ====================
  fastify.get('/config', adminController.getSystemConfig.bind(adminController));
  fastify.put('/config', adminController.updateSystemConfig.bind(adminController));

  // ==================== AUDIT LOGS ====================
  fastify.get('/audit-logs', adminController.getAuditLogs.bind(adminController));

  // ==================== REVENUE & BILLING ====================
  fastify.get('/revenue/analytics', adminController.getRevenueAnalytics.bind(adminController));
  fastify.post('/revenue/refund', adminController.processRefund.bind(adminController));

  // ==================== SUPPORT & TICKETS ====================
  fastify.get('/tickets/statistics', adminController.getTicketStats.bind(adminController));
  fastify.post('/tickets/:ticketId/assign', adminController.assignTicket.bind(adminController));

  // ==================== FEATURE USAGE ====================
  fastify.get('/features/usage', adminController.getFeatureUsage.bind(adminController));

  // ==================== ANNOUNCEMENTS ====================
  fastify.post('/announcements', adminController.createAnnouncement.bind(adminController));
  fastify.get('/announcements', adminController.getAnnouncements.bind(adminController));

  // ==================== DATA EXPORT ====================
  fastify.post('/export', adminController.exportData.bind(adminController));

  // ==================== COMPLIANCE ====================
  fastify.post('/compliance/report', adminController.generateComplianceReport.bind(adminController));
  fastify.post('/compliance/gdpr', adminController.handleGDPRRequest.bind(adminController));

  // Super Admin only routes
  fastify.register(async function superAdminRoutes(fastify: FastifyInstance) {
    fastify.addHook('onRequest', async (request, reply) => {
      if (request.customUser?.role !== 'SUPER_ADMIN') {
        reply.code(403).send({ error: 'Super admin access required' });
      }
    });

    // Dangerous operations
    fastify.post('/maintenance', async (request, reply) => {
      const systemConfigService = Container.get(await import('./system-config.service').then(m => m.SystemConfigService));
      await systemConfigService.toggleMaintenanceMode(true, request.body);
      reply.send({ message: 'Maintenance mode enabled' });
    });

    fastify.delete('/maintenance', async (request, reply) => {
      const systemConfigService = Container.get(await import('./system-config.service').then(m => m.SystemConfigService));
      await systemConfigService.toggleMaintenanceMode(false);
      reply.send({ message: 'Maintenance mode disabled' });
    });

    // System reset operations
    fastify.post('/system/reset-cache', async (request, reply) => {
      const { redis } = await import('@infrastructure/cache/redis.service');
      await redis.flushall();
      reply.send({ message: 'Cache cleared' });
    });
  });
}



// src/modules/admin/data-export.service.ts
import { Service } from 'typedi';
import { prisma } from '@infrastructure/database/prisma.service';
import { StorageService } from '@shared/services/storage.service';
import { logger } from '@shared/logger';
import { Parser } from 'json2csv';
import * as XLSX from 'xlsx';
import { format } from 'date-fns';
import { QueueService } from '@shared/queue/queue.service';
import { EmailService } from '@shared/services/email.service';
import { Prisma } from '@prisma/client';

export interface ExportOptions {
  entityType: 'users' | 'subscriptions' | 'invoices' | 'tickets' | 'analytics' | 'audit_logs' | 'projects' | 'tenants';
  format: 'csv' | 'json' | 'xlsx';
  filters?: Record<string, any>;
  dateRange?: {
    start: string;
    end: string;
  };
  includeRelations?: boolean;
  fields?: string[];
  limit?: number;
  async?: boolean;
  recipientEmail?: string;
}

export interface ExportResult {
  id: string;
  status: 'processing' | 'completed' | 'failed';
  url?: string;
  filename?: string;
  size?: number;
  error?: string;
  createdAt: Date;
  completedAt?: Date;
}

@Service()
export class DataExportService {
  private activeExports: Map<string, ExportResult> = new Map();

  constructor(
    private storageService: StorageService,
    private queueService: QueueService,
    private emailService: EmailService
  ) {}

  /**
   * Export data based on options
   */
  async export(options: ExportOptions): Promise<ExportResult> {
    const exportId = this.generateExportId();
    const exportResult: ExportResult = {
      id: exportId,
      status: 'processing',
      createdAt: new Date()
    };

    // Store export status
    this.activeExports.set(exportId, exportResult);

    if (options.async) {
      // Queue the export job
      await this.queueService.addJob('export', 'data-export', {
        exportId,
        options
      });

      logger.info('Export job queued', { exportId, entityType: options.entityType });

      return exportResult;
    }

    // Process synchronously
    try {
      const result = await this.processExport(exportId, options);
      return result;
    } catch (error) {
      exportResult.status = 'failed';
      exportResult.error = (error as Error).message;
      logger.error('Export failed', error as Error, { exportId });
      return exportResult;
    }
  }

  /**
   * Process the export
   */
  async processExport(exportId: string, options: ExportOptions): Promise<ExportResult> {
    const exportResult = this.activeExports.get(exportId) || {
      id: exportId,
      status: 'processing' as const,
      createdAt: new Date()
    };

    try {
      logger.info('Processing export', { exportId, entityType: options.entityType });

      // Fetch data
      const data = await this.fetchData(options);

      if (!data || data.length === 0) {
        throw new Error('No data found for export');
      }

      // Generate file
      const file = await this.generateFile(data, options);

      // Upload to storage
      const filename = this.generateFilename(options);
      const { url } = await this.storageService.upload({
        buffer: file,
        filename,
        mimeType: this.getMimeType(options.format),
        path: `exports/${format(new Date(), 'yyyy-MM-dd')}`
      });

      // Update result
      exportResult.status = 'completed';
      exportResult.url = url;
      exportResult.filename = filename;
      exportResult.size = file.length;
      exportResult.completedAt = new Date();

      // Send email if requested
      if (options.recipientEmail) {
        await this.sendExportEmail(options.recipientEmail, exportResult);
      }

      logger.info('Export completed', {
        exportId,
        filename,
        size: file.length,
        records: data.length
      });

      return exportResult;
    } catch (error) {
      exportResult.status = 'failed';
      exportResult.error = (error as Error).message;
      logger.error('Export processing failed', error as Error, { exportId });
      throw error;
    } finally {
      // Clean up after some time
      setTimeout(() => {
        this.activeExports.delete(exportId);
      }, 3600000); // 1 hour
    }
  }

  /**
   * Get export status
   */
  getExportStatus(exportId: string): ExportResult | null {
    return this.activeExports.get(exportId) || null;
  }

  /**
   * Fetch data based on entity type
   */
  private async fetchData(options: ExportOptions): Promise<any[]> {
    const { entityType, filters, dateRange, includeRelations, limit = 10000 } = options;

    let where: any = {};

    // Apply date range filter
    if (dateRange) {
      where.createdAt = {
        gte: new Date(dateRange.start),
        lte: new Date(dateRange.end)
      };
    }

    // Apply custom filters
    if (filters) {
      where = { ...where, ...filters };
    }

    switch (entityType) {
      case 'users':
        return this.exportUsers(where, includeRelations, limit);

      case 'subscriptions':
        return this.exportSubscriptions(where, includeRelations, limit);

      case 'invoices':
        return this.exportInvoices(where, includeRelations, limit);

      case 'tickets':
        return this.exportTickets(where, includeRelations, limit);

      case 'analytics':
        return this.exportAnalytics(where, limit);

      case 'audit_logs':
        return this.exportAuditLogs(where, limit);

      case 'projects':
        return this.exportProjects(where, includeRelations, limit);

      case 'tenants':
        return this.exportTenants(where, includeRelations, limit);

      default:
        throw new Error(`Unsupported entity type: ${entityType}`);
    }
  }

  /**
   * Export users
   */
  private async exportUsers(where: any, includeRelations?: boolean, limit?: number) {
    const users = await prisma.client.user.findMany({
      where,
      include: includeRelations ? {
        subscriptions: {
          where: { status: { in: ['ACTIVE', 'TRIALING'] } },
          take: 1
        },
        tenantMembers: {
          include: { tenant: true }
        },
        _count: {
          select: {
            sessions: true,
            tickets: true,
            projects: true,
            files: true
          }
        }
      } : undefined,
      take: limit
    });

    // Transform data for export
    return users.map(user => ({
      id: user.id,
      email: user.email,
      username: user.username,
      firstName: user.firstName,
      lastName: user.lastName,
      displayName: user.displayName,
      role: user.role,
      status: user.status,
      emailVerified: user.emailVerified,
      twoFactorEnabled: user.twoFactorEnabled,
      lastLoginAt: user.lastLoginAt,
      loginCount: user.loginCount,
      createdAt: user.createdAt,
      ...(includeRelations && {
        hasActiveSubscription: (user as any).subscriptions?.length > 0,
        tenants: (user as any).tenantMembers?.map((tm: any) => tm.tenant.name).join(', '),
        sessionCount: (user as any)._count?.sessions || 0,
        ticketCount: (user as any)._count?.tickets || 0,
        projectCount: (user as any)._count?.projects || 0,
        fileCount: (user as any)._count?.files || 0
      })
    }));
  }

  /**
   * Export subscriptions
   */
  private async exportSubscriptions(where: any, includeRelations?: boolean, limit?: number) {
    const subscriptions = await prisma.client.subscription.findMany({
      where,
      include: includeRelations ? {
        user: {
          select: {
            email: true,
            displayName: true
          }
        },
        tenant: {
          select: {
            name: true,
            slug: true
          }
        },
        invoices: {
          where: { status: 'PAID' },
          select: {
            amount: true,
            paidAt: true
          }
        }
      } : undefined,
      take: limit
    });

    return subscriptions.map(sub => ({
      id: sub.id,
      userId: sub.userId,
      tenantId: sub.tenantId,
      status: sub.status,
      stripePriceId: sub.stripePriceId,
      stripeProductId: sub.stripeProductId,
      currentPeriodStart: sub.currentPeriodStart,
      currentPeriodEnd: sub.currentPeriodEnd,
      cancelAtPeriodEnd: sub.cancelAtPeriodEnd,
      canceledAt: sub.canceledAt,
      trialEnd: sub.trialEnd,
      createdAt: sub.createdAt,
      ...(includeRelations && {
        userEmail: (sub as any).user?.email,
        userName: (sub as any).user?.displayName,
        tenantName: (sub as any).tenant?.name,
        totalRevenue: (sub as any).invoices?.reduce((sum: number, inv: any) => sum + inv.amount, 0) / 100 || 0
      })
    }));
  }

  /**
   * Export invoices
   */
  private async exportInvoices(where: any, includeRelations?: boolean, limit?: number) {
    const invoices = await prisma.client.invoice.findMany({
      where,
      include: includeRelations ? {
        subscription: {
          include: {
            user: {
              select: {
                email: true,
                displayName: true
              }
            },
            tenant: {
              select: {
                name: true
              }
            }
          }
        }
      } : undefined,
      take: limit
    });

    return invoices.map(inv => ({
      id: inv.id,
      subscriptionId: inv.subscriptionId,
      stripeInvoiceId: inv.stripeInvoiceId,
      amount: inv.amount / 100,
      currency: inv.currency,
      status: inv.status,
      periodStart: inv.periodStart,
      periodEnd: inv.periodEnd,
      paidAt: inv.paidAt,
      createdAt: inv.createdAt,
      ...(includeRelations && {
        userEmail: (inv as any).subscription?.user?.email,
        userName: (inv as any).subscription?.user?.displayName,
        tenantName: (inv as any).subscription?.tenant?.name
      })
    }));
  }

  /**
   * Export tickets
   */
  private async exportTickets(where: any, includeRelations?: boolean, limit?: number) {
    const tickets = await prisma.client.ticket.findMany({
      where,
      include: includeRelations ? {
        user: {
          select: {
            email: true,
            displayName: true
          }
        },
        assignee: {
          select: {
            email: true,
            displayName: true
          }
        },
        category: {
          select: {
            name: true
          }
        },
        _count: {
          select: {
            messages: true
          }
        }
      } : undefined,
      take: limit
    });

    return tickets.map(ticket => ({
      id: ticket.id,
      number: ticket.number,
      subject: ticket.subject,
      type: ticket.type,
      status: ticket.status,
      priority: ticket.priority,
      firstResponseAt: ticket.firstResponseAt,
      resolutionAt: ticket.resolutionAt,
      slaBreached: ticket.slaBreached,
      satisfactionRating: ticket.satisfactionRating,
      createdAt: ticket.createdAt,
      closedAt: ticket.closedAt,
      ...(includeRelations && {
        userEmail: (ticket as any).user?.email,
        userName: (ticket as any).user?.displayName,
        assigneeEmail: (ticket as any).assignee?.email,
        assigneeName: (ticket as any).assignee?.displayName,
        category: (ticket as any).category?.name,
        messageCount: (ticket as any)._count?.messages || 0
      })
    }));
  }

  /**
   * Export analytics events
   */
  private async exportAnalytics(where: any, limit?: number) {
    const events = await prisma.client.analyticsEvent.findMany({
      where,
      orderBy: { timestamp: 'desc' },
      take: limit
    });

    return events.map(event => ({
      id: event.id,
      userId: event.userId,
      tenantId: event.tenantId,
      event: event.event,
      properties: JSON.stringify(event.properties),
      sessionId: event.sessionId,
      deviceId: event.deviceId,
      ipAddress: event.ipAddress,
      userAgent: event.userAgent,
      referrer: event.referrer,
      utmSource: event.utmSource,
      utmMedium: event.utmMedium,
      utmCampaign: event.utmCampaign,
      timestamp: event.timestamp
    }));
  }

  /**
   * Export audit logs
   */
  private async exportAuditLogs(where: any, limit?: number) {
    const logs = await prisma.client.auditLog.findMany({
      where,
      include: {
        user: {
          select: {
            email: true,
            displayName: true
          }
        }
      },
      orderBy: { createdAt: 'desc' },
      take: limit
    });

    return logs.map(log => ({
      id: log.id,
      userId: log.userId,
      userEmail: (log as any).user?.email,
      userName: (log as any).user?.displayName,
      action: log.action,
      entity: log.entity,
      entityId: log.entityId,
      oldValues: JSON.stringify(log.oldValues),
      newValues: JSON.stringify(log.newValues),
      metadata: JSON.stringify(log.metadata),
      ipAddress: log.ipAddress,
      userAgent: log.userAgent,
      createdAt: log.createdAt
    }));
  }

  /**
   * Export projects
   */
  private async exportProjects(where: any, includeRelations?: boolean, limit?: number) {
    const projects = await prisma.client.project.findMany({
      where,
      include: includeRelations ? {
        user: {
          select: {
            email: true,
            displayName: true
          }
        },
        tenant: {
          select: {
            name: true
          }
        }
      } : undefined,
      take: limit
    });

    return projects.map(project => ({
      id: project.id,
      name: project.name,
      description: project.description,
      slug: project.slug,
      userId: project.userId,
      tenantId: project.tenantId,
      createdAt: project.createdAt,
      updatedAt: project.updatedAt,
      ...(includeRelations && {
        userEmail: (project as any).user?.email,
        userName: (project as any).user?.displayName,
        tenantName: (project as any).tenant?.name
      })
    }));
  }

  /**
   * Export tenants
   */
  private async exportTenants(where: any, includeRelations?: boolean, limit?: number) {
    const tenants = await prisma.client.tenant.findMany({
      where,
      include: includeRelations ? {
        owner: {
          select: {
            email: true,
            displayName: true
          }
        },
        subscription: true,
        _count: {
          select: {
            members: true,
            projects: true,
            tickets: true
          }
        }
      } : undefined,
      take: limit
    });

    return tenants.map(tenant => ({
      id: tenant.id,
      name: tenant.name,
      slug: tenant.slug,
      ownerId: tenant.ownerId,
      status: tenant.status,
      stripeCustomerId: tenant.stripeCustomerId,
      createdAt: tenant.createdAt,
      ...(includeRelations && {
        ownerEmail: (tenant as any).owner?.email,
        ownerName: (tenant as any).owner?.displayName,
        subscriptionStatus: (tenant as any).subscription?.status,
        memberCount: (tenant as any)._count?.members || 0,
        projectCount: (tenant as any)._count?.projects || 0,
        ticketCount: (tenant as any)._count?.tickets || 0
      })
    }));
  }

  /**
   * Generate file based on format
   */
  private async generateFile(data: any[], options: ExportOptions): Promise<Buffer> {
    // Filter fields if specified
    if (options.fields && options.fields.length > 0) {
      data = data.map(item => {
        const filtered: any = {};
        options.fields!.forEach(field => {
          if (field in item) {
            filtered[field] = item[field];
          }
        });
        return filtered;
      });
    }

    switch (options.format) {
      case 'csv':
        return this.generateCSV(data);

      case 'json':
        return Buffer.from(JSON.stringify(data, null, 2));

      case 'xlsx':
        return this.generateXLSX(data, options.entityType);

      default:
        throw new Error(`Unsupported format: ${options.format}`);
    }
  }

  /**
   * Generate CSV file
   */
  private generateCSV(data: any[]): Buffer {
    if (data.length === 0) {
      return Buffer.from('');
    }

    try {
      const parser = new Parser({
        fields: Object.keys(data[0])
      });
      return Buffer.from(parser.parse(data));
    } catch (error) {
      logger.error('CSV generation failed', error as Error);
      throw new Error('Failed to generate CSV');
    }
  }

  /**
   * Generate XLSX file
   */
  private generateXLSX(data: any[], sheetName: string): Buffer {
    try {
      const workbook = XLSX.utils.book_new();
      const worksheet = XLSX.utils.json_to_sheet(data);

      // Auto-size columns
      const maxWidth = 50;
      const colWidths = Object.keys(data[0] || {}).map(key => ({
        wch: Math.min(
          maxWidth,
          Math.max(
            key.length,
            ...data.map(row => String(row[key] || '').length)
          )
        )
      }));
      worksheet['!cols'] = colWidths;

      XLSX.utils.book_append_sheet(workbook, worksheet, sheetName);

      return Buffer.from(XLSX.write(workbook, { type: 'buffer', bookType: 'xlsx' }));
    } catch (error) {
      logger.error('XLSX generation failed', error as Error);
      throw new Error('Failed to generate XLSX');
    }
  }

  /**
   * Send export completion email
   */
  private async sendExportEmail(recipientEmail: string, exportResult: ExportResult) {
    await this.emailService.queue({
      to: recipientEmail,
      subject: 'Your data export is ready',
      template: 'export-ready',
      context: {
        downloadUrl: exportResult.url,
        filename: exportResult.filename,
        expiresIn: '24 hours'
      }
    });
  }

  // Helper methods

  private generateExportId(): string {
    return `export_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  private generateFilename(options: ExportOptions): string {
    const timestamp = format(new Date(), 'yyyy-MM-dd-HHmmss');
    return `${options.entityType}-export-${timestamp}.${options.format}`;
  }

  private getMimeType(format: string): string {
    const mimeTypes = {
      csv: 'text/csv',
      json: 'application/json',
      xlsx: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    };
    return mimeTypes[format as keyof typeof mimeTypes] || 'application/octet-stream';
  }
}




// src/modules/admin/admin.middleware.ts
import { FastifyRequest, FastifyReply } from 'fastify';
import { UnauthorizedException, ForbiddenException } from '@shared/exceptions';
import { logger } from '@shared/logger';
import { redis } from '@infrastructure/cache/redis.service';
import { prisma } from '@infrastructure/database/prisma.service';
import { AuditService } from '@shared/services/audit.service';
import { Container } from 'typedi';

export interface AdminAuthOptions {
  requireSuperAdmin?: boolean;
  allowedRoles?: string[];
  checkIpWhitelist?: boolean;
  trackActivity?: boolean;
  rateLimit?: {
    max: number;
    window: number; // in seconds
  };
}

/**
 * Admin authentication middleware
 */
export function adminAuth(options: AdminAuthOptions = {}) {
  return async (request: FastifyRequest, reply: FastifyReply) => {
    try {
      // Check if user is authenticated
      if (!request.customUser) {
        throw new UnauthorizedException('Authentication required');
      }

      const user = request.customUser;

      // Check if user has admin role
      const allowedRoles = options.allowedRoles || ['ADMIN', 'SUPER_ADMIN'];
      if (!allowedRoles.includes(user.role)) {
        throw new ForbiddenException('Admin access required');
      }

      // Check if super admin is required
      if (options.requireSuperAdmin && user.role !== 'SUPER_ADMIN') {
        throw new ForbiddenException('Super admin access required');
      }

      // Check IP whitelist if enabled
      if (options.checkIpWhitelist) {
        await checkIpWhitelist(request.ip, user.id);
      }

      // Apply rate limiting if specified
      if (options.rateLimit) {
        await checkRateLimit(user.id, options.rateLimit);
      }

      // Track admin activity
      if (options.trackActivity !== false) {
        await trackAdminActivity(request, user.id);
      }

      // Add admin context to request
      (request as any).adminContext = {
        userId: user.id,
        role: user.role,
        ip: request.ip,
        timestamp: new Date()
      };

    } catch (error) {
      logger.error('Admin auth failed', error as Error, {
        userId: request.customUser?.id,
        path: request.url,
        ip: request.ip
      });
      throw error;
    }
  };
}

/**
 * Check if IP is whitelisted for admin access
 */
async function checkIpWhitelist(ip: string, userId: string): Promise<void> {
  // Get system config from cache or database
  const configKey = 'system:config:security.allowedIps';
  let allowedIps = await redis.get<string[]>(configKey);

  if (!allowedIps) {
    // Fetch from database
    const setting = await prisma.client.setting.findUnique({
      where: { key: 'security.allowedIps' }
    });

    if (setting && setting.value) {
      allowedIps = setting.value as string[];
      await redis.set(configKey, allowedIps, { ttl: 3600 });
    }
  }

  if (allowedIps && allowedIps.length > 0 && !allowedIps.includes(ip)) {
    logger.security('Admin access denied - IP not whitelisted', {
      userId,
      ip,
      allowedIps
    });
    throw new ForbiddenException('Access denied from this IP address');
  }
}

/**
 * Check admin rate limit
 */
async function checkRateLimit(
  userId: string,
  limits: { max: number; window: number }
): Promise<void> {
  const key = `admin:ratelimit:${userId}`;
  const current = await redis.increment(key);

  if (current === 1) {
    await redis.expire(key, limits.window);
  }

  if (current > limits.max) {
    logger.security('Admin rate limit exceeded', {
      userId,
      limit: limits.max,
      window: limits.window,
      current
    });
    throw new ForbiddenException('Rate limit exceeded');
  }
}

/**
 * Track admin activity
 */
async function trackAdminActivity(request: FastifyRequest, userId: string): Promise<void> {
  try {
    // Update last admin activity
    const activityKey = `admin:activity:${userId}`;
    await redis.set(activityKey, {
      lastActivity: new Date(),
      endpoint: request.url,
      method: request.method,
      ip: request.ip,
      userAgent: request.headers['user-agent']
    }, { ttl: 86400 }); // 24 hours

    // Track in analytics
    await prisma.client.analyticsEvent.create({
      data: {
        userId,
        event: 'admin.activity',
        properties: {
          endpoint: request.url,
          method: request.method,
          action: getActionFromEndpoint(request.url)
        },
        ipAddress: request.ip,
        userAgent: request.headers['user-agent'] as string,
        timestamp: new Date()
      }
    });
  } catch (error) {
    logger.error('Failed to track admin activity', error as Error);
    // Don't throw - this shouldn't block the request
  }
}

/**
 * Permission-based middleware for specific admin actions
 */
export function requirePermission(permission: string) {
  return async (request: FastifyRequest, reply: FastifyReply) => {
    const user = request.customUser;

    if (!user) {
      throw new UnauthorizedException('Authentication required');
    }

    // Super admins have all permissions
    if (user.role === 'SUPER_ADMIN') {
      return;
    }

    // Check if user has specific permission
    const hasPermission = await checkUserPermission(user.id, permission);

    if (!hasPermission) {
      const auditService = Container.get(AuditService);
      await auditService.log({
        userId: user.id,
        action: 'permission.denied',
        entity: 'admin',
        metadata: {
          permission,
          endpoint: request.url
        }
      });

      throw new ForbiddenException(`Permission denied: ${permission}`);
    }
  };
}

/**
 * Check if user has specific permission
 */
async function checkUserPermission(userId: string, permission: string): Promise<boolean> {
  // This would typically check against a permissions table
  // For now, we'll use a simple role-based check

  const user = await prisma.client.user.findUnique({
    where: { id: userId },
    select: { role: true }
  });

  if (!user) return false;

  // Define permissions by role
  const rolePermissions: Record<string, string[]> = {
    ADMIN: [
      'users.view',
      'users.update',
      'tickets.view',
      'tickets.manage',
      'content.moderate',
      'analytics.view',
      'announcements.create',
      'export.data'
    ],
    SUPER_ADMIN: ['*'] // All permissions
  };

  const permissions = rolePermissions[user.role] || [];
  return permissions.includes('*') || permissions.includes(permission);
}

/**
 * Audit sensitive admin actions
 */
export function auditAction(action: string) {
  return async (request: FastifyRequest, reply: FastifyReply) => {
    const user = request.customUser;
    const adminContext = (request as any).adminContext;

    if (!user || !adminContext) {
      return;
    }

    const auditService = Container.get(AuditService);

    await auditService.log({
      userId: user.id,
      action: `admin.${action}`,
      entity: 'admin',
      entityId: request.params ? JSON.stringify(request.params) : null,
      metadata: {
        endpoint: request.url,
        method: request.method,
        body: request.body,
        query: request.query,
        ip: request.ip,
        userAgent: request.headers['user-agent']
      }
    });
  };
}

/**
 * Check if system is in maintenance mode
 */
export async function checkMaintenanceMode(request: FastifyRequest, reply: FastifyReply) {
  const maintenanceKey = 'system:maintenance:enabled';
  const isInMaintenance = await redis.get<boolean>(maintenanceKey);

  if (isInMaintenance) {
    // Check if user is admin (admins can access during maintenance)
    if (!request.customUser || !['ADMIN', 'SUPER_ADMIN'].includes(request.customUser.role)) {
      const maintenanceInfo = await redis.get<any>('system:maintenance:info') || {
        message: 'System is under maintenance'
      };

      reply.code(503).send({
        error: 'Service Unavailable',
        message: maintenanceInfo.message,
        estimatedDuration: maintenanceInfo.estimatedDuration
      });
    }
  }
}

/**
 * Validate admin session
 */
export async function validateAdminSession(request: FastifyRequest, reply: FastifyReply) {
  const user = request.customUser;

  if (!user || !['ADMIN', 'SUPER_ADMIN'].includes(user.role)) {
    return;
  }

  // Check if admin session is still valid
  const sessionKey = `admin:session:${user.id}`;
  const session = await redis.get<any>(sessionKey);

  if (!session) {
    // Create new admin session
    await redis.set(sessionKey, {
      userId: user.id,
      startedAt: new Date(),
      lastActivity: new Date(),
      ip: request.ip
    }, { ttl: 3600 }); // 1 hour
  } else {
    // Update last activity
    session.lastActivity = new Date();
    await redis.set(sessionKey, session, { ttl: 3600 });

    // Check for suspicious activity
    if (session.ip !== request.ip) {
      logger.security('Admin session IP mismatch', {
        userId: user.id,
        sessionIp: session.ip,
        currentIp: request.ip
      });

      // Could enforce stricter security here
    }
  }
}

// Helper functions

function getActionFromEndpoint(url: string): string {
  const parts = url.split('/').filter(Boolean);
  if (parts.length >= 3) {
    return `${parts[2]}.${parts[3] || 'view'}`;
  }
  return 'unknown';
}


// src/modules/admin/index.ts
import { Container } from 'typedi';
import { logger } from '@shared/logger';
import { QueueService } from '@shared/queue/queue.service';
import { EventBus } from '@shared/events/event-bus';
import { AdminUserService } from './admin-user.service';
import { AdminMetricsService } from './admin-metrics.service';
import { AdminModerationService } from './admin-moderation.service';
import { SystemConfigService } from './system-config.service';
import { AnnouncementService } from './announcement.service';
import { DataExportService } from './data-export.service';
import { AdminController } from './admin.controller';
import { redis } from '@infrastructure/cache/redis.service';
import { prisma } from '@infrastructure/database/prisma.service';

// Export all admin services
export * from './admin-user.service';
export * from './admin-metrics.service';
export * from './admin-moderation.service';
export * from './system-config.service';
export * from './announcement.service';
export * from './data-export.service';
export * from './admin.controller';
export * from './admin.middleware';
export * from './admin.dto';

// Export routes
export { default as adminRoutes } from './admin.route';

/**
 * Initialize the admin module
 */
export async function initializeAdminModule(): Promise<void> {
  try {
    logger.info('Initializing admin module...');

    // Initialize services
    const adminUserService = Container.get(AdminUserService);
    const adminMetricsService = Container.get(AdminMetricsService);
    const adminModerationService = Container.get(AdminModerationService);
    const systemConfigService = Container.get(SystemConfigService);
    const announcementService = Container.get(AnnouncementService);
    const dataExportService = Container.get(DataExportService);
    const queueService = Container.get(QueueService);
    const eventBus = Container.get(EventBus);

    // Register queue processors
    queueService.registerProcessor('export', 'data-export', async (job) => {
      const { exportId, options } = job.data;
      return await dataExportService.processExport(exportId, options);
    });

    queueService.registerProcessor('admin', 'audit-cleanup', async (job) => {
      const { retentionDays = 90 } = job.data;
      const cutoffDate = new Date();
      cutoffDate.setDate(cutoffDate.getDate() - retentionDays);

      const result = await prisma.client.auditLog.deleteMany({
        where: {
          createdAt: { lt: cutoffDate }
        }
      });

      logger.info('Audit logs cleaned up', {
        deleted: result.count,
        retentionDays
      });

      return { deleted: result.count };
    });

    queueService.registerProcessor('admin', 'metrics-aggregation', async (job) => {
      // Aggregate metrics for dashboard
      const metrics = await adminMetricsService.getSystemMetrics();

      // Cache aggregated metrics
      await redis.set('admin:metrics:aggregated', metrics, { ttl: 300 });

      logger.info('Metrics aggregated successfully');

      return { status: 'completed' };
    });

    // Schedule recurring admin jobs
    await scheduleAdminJobs(queueService);

    // Register event handlers
    registerAdminEventHandlers(eventBus);

    // Initialize default system configuration
    await initializeSystemConfig(systemConfigService);

    // Set up real-time metrics collection
    await setupMetricsCollection();

    logger.info('Admin module initialized successfully');
  } catch (error) {
    logger.error('Failed to initialize admin module', error as Error);
    throw error;
  }
}

/**
 * Schedule recurring admin jobs
 */
async function scheduleAdminJobs(queueService: QueueService): Promise<void> {
  // Audit log cleanup - daily at 3 AM
  await queueService.addJob(
    'admin',
    'audit-cleanup',
    { retentionDays: 90 },
    {
      repeat: { cron: '0 3 * * *' }
    }
  );

  // Metrics aggregation - every 5 minutes
  await queueService.addJob(
    'admin',
    'metrics-aggregation',
    {},
    {
      repeat: { cron: '*/5 * * * *' }
    }
  );

  // System health check - every minute
  await queueService.addJob(
    'admin',
    'health-check',
    {},
    {
      repeat: { cron: '* * * * *' }
    }
  );

  logger.info('Admin recurring jobs scheduled');
}

/**
 * Register admin event handlers
 */
function registerAdminEventHandlers(eventBus: EventBus): void {
  // User events
  eventBus.on('user.suspended', async (payload: any) => {
    logger.info('User suspended event received', payload);
    // Could send notifications, update metrics, etc.
  });

  eventBus.on('user.deleted', async (payload: any) => {
    logger.info('User deleted event received', payload);
    // Clean up user data, update metrics
  });

  // System events
  eventBus.on('system.maintenance.enabled', async (payload: any) => {
    // Cache maintenance status for quick checks
    await redis.set('system:maintenance:enabled', true, { ttl: 86400 });
    await redis.set('system:maintenance:info', payload, { ttl: 86400 });
  });

  eventBus.on('system.maintenance.disabled', async () => {
    await redis.delete('system:maintenance:enabled');
    await redis.delete('system:maintenance:info');
  });

  // Config events
  eventBus.on('admin.config.updated', async (payload: any) => {
    // Clear config cache to force reload
    await redis.delete('system:config:*');
  });

  // Security events
  eventBus.on('security.threat.detected', async (payload: any) => {
    logger.security('Security threat detected', payload);
    // Could trigger automatic responses
  });
}

/**
 * Initialize default system configuration
 */
async function initializeSystemConfig(configService: SystemConfigService): Promise<void> {
  try {
    // Check if config exists
    const existingConfig = await configService.getConfig();

    if (!existingConfig || Object.keys(existingConfig).length === 0) {
      logger.info('Initializing default system configuration');

      // Set default configuration
      await configService.updateConfig({
        maintenance: {
          enabled: false,
          message: 'The system is currently under maintenance. Please check back later.'
        },
        features: {
          registration: true,
          oauth: true,
          twoFactor: true,
          emailVerification: true,
          apiAccess: true,
          fileUpload: true,
          publicProfiles: false
        },
        limits: {
          maxUsersPerTenant: 100,
          maxProjectsPerUser: 50,
          maxFileSize: 10 * 1024 * 1024, // 10MB
          maxStoragePerUser: 1024 * 1024 * 1024, // 1GB
          apiRateLimit: 100,
          maxTeamSize: 50,
          maxConcurrentSessions: 5
        },
        security: {
          passwordMinLength: 8,
          passwordRequireUppercase: true,
          passwordRequireLowercase: true,
          passwordRequireNumbers: true,
          passwordRequireSpecial: true,
          sessionTimeout: 60,
          maxLoginAttempts: 5,
          lockoutDuration: 15,
          enforceIpWhitelist: false,
          requireEmailVerification: true,
          require2FAForAdmins: false
        }
      });
    }
  } catch (error) {
    logger.error('Failed to initialize system config', error as Error);
  }
}

/**
 * Set up real-time metrics collection
 */
async function setupMetricsCollection(): Promise<void> {
  // Initialize metrics counters
  await redis.set('metrics:requests:total', 0);
  await redis.set('metrics:errors:total', 0);

  // Set up periodic metrics reset
  setInterval(async () => {
    try {
      // Get current values
      const requests = await redis.get('metrics:requests:1min') || 0;
      const errors = await redis.get('metrics:errors:1min') || 0;

      // Calculate rates
      const rpm = Number(requests);
      const epm = Number(errors);

      // Store rates
      await redis.set('metrics:rpm', rpm);
      await redis.set('metrics:epm', epm);

      // Reset counters
      await redis.set('metrics:requests:1min', 0);
      await redis.set('metrics:errors:1min', 0);

      // Update 5-minute counters
      await redis.increment('metrics:requests:5min', rpm);
      await redis.increment('metrics:errors:5min', epm);

    } catch (error) {
      logger.error('Metrics collection error', error as Error);
    }
  }, 60000); // Every minute

  // Reset 5-minute counters
  setInterval(async () => {
    await redis.set('metrics:requests:5min', 0);
    await redis.set('metrics:errors:5min', 0);
  }, 300000); // Every 5 minutes

  logger.info('Real-time metrics collection started');
}

/**
 * Shutdown the admin module
 */
export async function shutdownAdminModule(): Promise<void> {
  try {
    logger.info('Shutting down admin module...');

    // Clear any cached data
    await redis.delete('admin:*');
    await redis.delete('system:*');

    logger.info('Admin module shut down successfully');
  } catch (error) {
    logger.error('Error shutting down admin module', error as Error);
  }
}
